import express from 'express'
import cors from 'cors'
import Database from 'better-sqlite3'
import { fileURLToPath } from 'url'
import { dirname, join } from 'path'
import { writeFileSync, existsSync, mkdirSync } from 'fs'
import { GoogleGenAI } from '@google/genai'
import dotenv from 'dotenv'

// ç’°å¢ƒå¤‰æ•°èª­ã¿è¾¼ã¿
dotenv.config()

const __filename = fileURLToPath(import.meta.url)
const __dirname = dirname(__filename)

const app = express()
const PORT = process.env.PORT || 3001

// Gemini AI ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆåˆæœŸåŒ–
const genAI = new GoogleGenAI({ apiKey: process.env.GEMINI_API_KEY })

// ãƒŸãƒ‰ãƒ«ã‚¦ã‚§ã‚¢
app.use(cors())
app.use(express.json())

// é™çš„ãƒ•ã‚¡ã‚¤ãƒ«é…ä¿¡ï¼ˆå‹•ç”»ï¼‰
app.use('/videos', express.static(join(__dirname, '../public/videos')))

// D1ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹æ¥ç¶šï¼ˆãƒ­ãƒ¼ã‚«ãƒ«SQLiteï¼‰
const dbPath = join(__dirname, '../.wrangler/state/v3/d1/miniflare-D1DatabaseObject/7a321e1c997ab8e153b965c9a6bb80991f6ac35f4a46ec49f72ed2d92fc44616.sqlite')
let db

try {
  db = new Database(dbPath)
  console.log('âœ… Database connected:', dbPath)
} catch (error) {
  console.error('âŒ Database connection failed:', error.message)
  console.log('Please run: npx wrangler d1 migrations apply youtube-ai-db --local')
}

// ãƒ˜ãƒ«ã‚¹ãƒã‚§ãƒƒã‚¯
app.get('/health', (req, res) => {
  res.json({ status: 'ok', timestamp: new Date().toISOString() })
})

// YouTubeè¨­å®šè‡ªå‹•ç”Ÿæˆã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆ
app.post('/api/generate-youtube-settings', (req, res) => {
  try {
    const { character, video, music } = req.body
    
    const actionMap = {
      'singing': 'æ­Œã£ã¦ã„ã‚‹',
      'dancing': 'è¸Šã£ã¦ã„ã‚‹',
      'talking': 'å–‹ã£ã¦ã„ã‚‹',
      'playing': 'æ¼”å¥ã—ã¦ã„ã‚‹'
    }
    
    const instrumentMap = {
      'acoustic-guitar': 'ã‚¢ã‚³ãƒ¼ã‚¹ãƒ†ã‚£ãƒƒã‚¯ã‚®ã‚¿ãƒ¼',
      'piano': 'ãƒ”ã‚¢ãƒ',
      'drum': 'ãƒ‰ãƒ©ãƒ ',
      'flute': 'ãƒ•ãƒ«ãƒ¼ãƒˆ',
      'electric-guitar': 'ã‚¨ãƒ¬ã‚­ã‚®ã‚¿ãƒ¼',
      'violin': 'ãƒã‚¤ã‚ªãƒªãƒ³',
      'ukulele': 'ã‚¦ã‚¯ãƒ¬ãƒ¬'
    }
    
    const genreMap = {
      'pop': 'ãƒãƒƒãƒ—',
      'ballad': 'ãƒãƒ©ãƒ¼ãƒ‰',
      'rock': 'ãƒ­ãƒƒã‚¯',
      'folk': 'ãƒ•ã‚©ãƒ¼ã‚¯',
      'jazz': 'ã‚¸ãƒ£ã‚º',
      'acoustic': 'ã‚¢ã‚³ãƒ¼ã‚¹ãƒ†ã‚£ãƒƒã‚¯'
    }
    
    const action = actionMap[video.action] || video.action
    const instrument = instrumentMap[video.instrument] || video.instrument
    const genre = genreMap[music.genre] || music.genre
    const theme = video.theme || 'éŸ³æ¥½'
    
    // ã‚¿ã‚¤ãƒˆãƒ«ç”Ÿæˆ
    let title = ''
    if (video.action === 'playing' || video.action === 'singing') {
      title = `ã€AIç”Ÿæˆã€‘${theme}ã®${genre} | ${instrument}${action}å‹•ç”»`
    } else {
      title = `ã€AIç”Ÿæˆã€‘${theme}ãŒãƒ†ãƒ¼ãƒã®${genre}å‹•ç”»`
    }
    
    // èª¬æ˜æ–‡ç”Ÿæˆ
    const description = `ã“ã®å‹•ç”»ã¯AIã«ã‚ˆã£ã¦è‡ªå‹•ç”Ÿæˆã•ã‚Œã¾ã—ãŸã€‚

ğŸµ ãƒ†ãƒ¼ãƒ: ${theme}
ğŸ¸ ã‚¸ãƒ£ãƒ³ãƒ«: ${genre}
${video.action === 'playing' || video.action === 'singing' ? `ğŸ¹ æ¥½å™¨: ${instrument}` : ''}
â±ï¸ é•·ã•: ${video.duration}ç§’
ğŸ“ ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆ: ${video.aspectRatio === '9:16' ? 'YouTube Shorts' : 'YouTubeå‹•ç”»'}

#AIç”Ÿæˆ #${genre} #${theme} #éŸ³æ¥½å‹•ç”» #AIã‚¢ãƒ¼ãƒˆ

---
Generated by AI Video Auto-Upload System`
    
    // ã‚¿ã‚°ç”Ÿæˆ
    const tags = [
      'AIç”Ÿæˆ',
      'AIéŸ³æ¥½',
      genre,
      theme,
      video.action === 'playing' || video.action === 'singing' ? instrument : '',
      video.aspectRatio === '9:16' ? 'Shorts' : '',
      music.language === 'japanese' ? 'æ—¥æœ¬èª' : 'è‹±èª'
    ].filter(Boolean)
    
    res.json({
      success: true,
      youtube: {
        title,
        description,
        tags: tags.join(', ')
      }
    })
    
  } catch (error) {
    console.error('âŒ YouTube settings generation error:', error)
    res.status(500).json({
      success: false,
      error: error.message
    })
  }
})

// AIå‹•ç”»ç”Ÿæˆãƒªã‚¯ã‚¨ã‚¹ãƒˆã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆï¼ˆãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰ â†’ AIï¼‰
app.post('/api/request-video-generation', async (req, res) => {
  try {
    const config = req.body
    const prompt = buildVideoPrompt(config)
    
    // AIã«å‹•ç”»ç”Ÿæˆã‚’ãƒªã‚¯ã‚¨ã‚¹ãƒˆï¼ˆå®Ÿéš›ã®ç”Ÿæˆã¯åˆ¥ãƒ—ãƒ­ã‚»ã‚¹ï¼‰
    res.json({
      success: true,
      message: 'Video generation requested. Please wait...',
      prompt: prompt,
      requestId: Date.now()
    })
  } catch (error) {
    console.error('âŒ Request error:', error)
    res.status(500).json({ success: false, error: error.message })
  }
})

// å‹•ç”»ç”Ÿæˆã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆ
app.post('/api/generate', async (req, res) => {
  try {
    const config = req.body
    console.log('ğŸ“ Generation request received:', config)

    // ã‚¹ãƒ†ãƒƒãƒ—1: ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆæ§‹ç¯‰
    const prompt = buildVideoPrompt(config)
    console.log('ğŸ¬ Video prompt:', prompt)

    // ã‚¹ãƒ†ãƒƒãƒ—2: Gemini Veo 3ã§å‹•ç”»ç”Ÿæˆ
    console.log('ğŸ¥ Generating video with Gemini Veo 3...')
    
    try {
      // Gemini Veo 3 APIå‘¼ã³å‡ºã—
      const operation = await genAI.models.generateVideos({
        model: 'veo-3.0-generate-001',
        prompt: prompt,
        config: {
          personGeneration: 'allow_all'
        }
      })
      
      console.log('ğŸ“¦ Video generation started, operation:', operation.name)
      
      // å‹•ç”»ç”Ÿæˆå®Œäº†ã‚’å¾…ã¤ï¼ˆãƒãƒ¼ãƒªãƒ³ã‚°ï¼‰
      let pollingOperation = operation
      let pollCount = 0
      const maxPolls = 60 // æœ€å¤§10åˆ†ï¼ˆ10ç§’x60ï¼‰
      
      while (!pollingOperation.done && pollCount < maxPolls) {
        console.log(`â³ Waiting for video generation... (${pollCount + 1}/${maxPolls})`)
        await new Promise(resolve => setTimeout(resolve, 10000)) // 10ç§’å¾…æ©Ÿ
        pollingOperation = await genAI.operations.get(pollingOperation)
        pollCount++
      }
      
      if (!pollingOperation.done) {
        throw new Error('Video generation timeout after 10 minutes')
      }
      
      console.log('âœ… Video generation completed!')
      
      // ç”Ÿæˆã•ã‚ŒãŸå‹•ç”»ã‚’å–å¾—
      const generatedVideo = pollingOperation.response.generatedVideos[0]
      console.log('ğŸ“¹ Generated video:', generatedVideo.video.name)
      
      const videoId = Date.now()
      const videoFilename = `video_${videoId}.mp4`
      const videoPath = join(__dirname, '..', 'public', 'videos', videoFilename)
      
      // ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã‚’ä½œæˆ
      const videoDir = dirname(videoPath)
      if (!existsSync(videoDir)) {
        mkdirSync(videoDir, { recursive: true })
      }
      
      // å‹•ç”»ã‚’ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰
      console.log('ğŸ“¥ Downloading video...')
      const fileData = await genAI.files.download({ file: generatedVideo.video })
      writeFileSync(videoPath, fileData)
      console.log('ğŸ’¾ Video saved to:', videoPath)
      
    } catch (error) {
      console.error('âŒ Gemini video generation failed:', error.message)
      console.log('âš ï¸ Falling back to placeholder')
      
      const videoId = Date.now()
      const videoFilename = `video_${videoId}.mp4`
      const videoPath = join(__dirname, '..', 'public', 'videos', videoFilename)
      
      // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯: ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’è¿”ã™
      throw new Error('Video generation failed: ' + error.message)
    }
    
    // å…¬é–‹URL
    const publicVideoUrl = `/videos/${videoFilename}`
    
    const videoResult = {
      videoUrl: publicVideoUrl,
      thumbnailUrl: publicVideoUrl,
      duration: config.video.duration,
      videoId: videoId
    }

    // ã‚¹ãƒ†ãƒƒãƒ—3: ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã«ä¿å­˜
    if (db) {
      const stmt = db.prepare(`
        INSERT INTO videos (
          character_mode, character_image_url, character_prompt,
          action, instrument, theme, aspect_ratio, duration,
          genre, language, lyrics,
          video_url, thumbnail_url,
          youtube_title, youtube_description, youtube_tags,
          youtube_status
        ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
      `)

      const result = stmt.run(
        config.character.mode,
        config.character.imageUrl || null,
        config.character.prompt || null,
        config.video.action,
        config.video.instrument || null,
        config.video.theme,
        config.video.aspectRatio,
        config.video.duration,
        config.music.genre,
        config.music.language,
        config.music.lyrics || null,
        videoResult.videoUrl,
        videoResult.thumbnailUrl,
        config.youtube.title,
        config.youtube.description,
        config.youtube.tags,
        'pending'
      )

      console.log('âœ… Saved to database, ID:', result.lastInsertRowid)
    }

    res.json({
      success: true,
      data: {
        videoUrl: videoResult.videoUrl,
        thumbnailUrl: videoResult.thumbnailUrl,
        prompt: prompt,
        youtube: config.youtube
      }
    })

  } catch (error) {
    console.error('âŒ Generation error:', error)
    res.status(500).json({
      success: false,
      error: error.message
    })
  }
})

// å±¥æ­´å–å¾—ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆ
app.get('/api/history', (req, res) => {
  try {
    if (!db) {
      return res.json({ success: true, history: [] })
    }

    const stmt = db.prepare(`
      SELECT * FROM videos 
      ORDER BY created_at DESC 
      LIMIT 50
    `)
    const history = stmt.all()

    res.json({
      success: true,
      history: history
    })

  } catch (error) {
    console.error('âŒ History fetch error:', error)
    res.status(500).json({
      success: false,
      error: error.message
    })
  }
})

// ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ä¿å­˜ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆ
app.post('/api/save-schedule', (req, res) => {
  try {
    const schedule = req.body
    console.log('ğŸ“… Schedule save request:', schedule)

    if (!db) {
      return res.json({ 
        success: true, 
        message: 'ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’ä¿å­˜ã—ã¾ã—ãŸï¼ˆDBæœªæ¥ç¶šï¼‰' 
      })
    }

    // æ—¢å­˜ã®ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’æ›´æ–°
    const stmt = db.prepare(`
      UPDATE schedules SET
        enabled = ?,
        slot1_enabled = 1,
        slot1_time = ?,
        slot2_enabled = 0,
        slot2_time = NULL,
        slot3_enabled = 0,
        slot3_time = NULL,
        slot4_enabled = 0,
        slot4_time = NULL,
        privacy = ?,
        updated_at = CURRENT_TIMESTAMP
      WHERE id = 1
    `)

    stmt.run(
      schedule.enabled ? 1 : 0,
      schedule.time || null,
      schedule.privacy || 'public'
    )

    res.json({
      success: true,
      message: `ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’ä¿å­˜ã—ã¾ã—ãŸï¼ˆæ¯æ—¥ ${schedule.time || 'æœªè¨­å®š'}ï¼‰`
    })

  } catch (error) {
    console.error('âŒ Schedule save error:', error)
    res.status(500).json({
      success: false,
      error: error.message
    })
  }
})

// ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆæ§‹ç¯‰é–¢æ•°
function buildVideoPrompt(config) {
  const actionMap = {
    'singing': 'singing',
    'dancing': 'dancing',
    'talking': 'talking',
    'playing': 'playing'
  }

  const instrumentMap = {
    'acoustic-guitar': 'acoustic guitar',
    'piano': 'piano',
    'drum': 'drums',
    'flute': 'flute',
    'electric-guitar': 'electric guitar',
    'violin': 'violin',
    'ukulele': 'ukulele'
  }

  let prompt = ''

  // ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼èª¬æ˜
  if (config.character.mode === 'prompt' && config.character.prompt) {
    prompt += config.character.prompt + ', '
  } else {
    prompt += 'A professional musician, '
  }

  // ã‚¢ã‚¯ã‚·ãƒ§ãƒ³
  const action = actionMap[config.video.action] || config.video.action
  prompt += action

  // æ¥½å™¨
  if (config.video.action === 'playing' && config.video.instrument) {
    const instrument = instrumentMap[config.video.instrument] || config.video.instrument
    prompt += ` the ${instrument}`
  }

  // ãƒ†ãƒ¼ãƒãƒ»ã‚¸ãƒ£ãƒ³ãƒ«
  prompt += `, ${config.video.theme} theme, ${config.music.genre} music style`

  // è¨€èª
  prompt += `, ${config.music.language} lyrics`

  // æ­Œè©ï¼ˆä¸€éƒ¨ï¼‰
  if (config.music.lyrics) {
    const lyricsPreview = config.music.lyrics.substring(0, 100)
    prompt += `, with lyrics: "${lyricsPreview}..."`
  }

  // å“è³ªè¨­å®š
  prompt += ', professional music video quality, cinematic lighting, emotional performance'

  return prompt
}

// ã‚µãƒ¼ãƒãƒ¼èµ·å‹•
app.listen(PORT, '0.0.0.0', () => {
  console.log(`ğŸš€ Backend API server running on http://0.0.0.0:${PORT}`)
  console.log(`ğŸ“Š Health check: http://localhost:${PORT}/health`)
})
